'''
    dict和set的背后
        理解Python里字典和集合类型的长处和弱点，背后的散列表是必须先了解的。
        在一个1000万的可迭代对象中寻找1000个可迭代对象是否包含在其中
        最快的是使用set取交集
        最慢的是使用list，每次都需要循环一次列表用于查找
    3.9.2 字典中的散列表
        散列表其实是一个稀疏数组(总有空白元素的数组称为洗漱数组)。在一般的数据结构教材中，散列表里的单元通常叫做表元(bucket)。在dict的散列表当中，每个键值对都占用一个表元，每个表元都有两个部分，一个是对键的引用，一个是对值的引用。因为所有表元的大小一致，所以可以通过偏移量来读取某个表元。
        Python会设法保证大概还有三分之一的表元是空的，所以在快要达到阈值的时候，原有的散列表会被复制到一个更大的空间里
        要把一个对象放入散列表，首先需要计算这个元素值的散列值，Python中可以用hash()方法来完成这件事。
        01.散列表和相等性
            内置的hash()方法可以用于所有的内置类型对象。如果对自定义对象调用hash()方法，实际上运行的是自定义的__hash__方法。如果两个对象在比较的时候时相等的，那它们的散列值必须相等。
            为了让散列值能够胜任散列表索引，必须在索引空间中尽量分散。在最理想的状况下，越是相似但不相等的对象，散列值差别应该越大。
            Python3.3开始，str、bytes和datetime对象的散列值计算过程中多了随机的加盐这一步。所加盐值是Python进程内的一个常量，但是每次启动Python解释器都会生成一个不同的盐值。随机盐值是为了防止dos攻击而采取的一种安全措施。
        02.散列表算法
            为了获取my_dict[search_key]背后的值，Python首先会调用hash(search_key)来计算search_key的散列值，把这个值最低的几位数字当做偏移量，在散列表里查找表元。若找到的表元是空的，则抛出KeyError异常。若不是空的，则表元里会有一对found_key:found_value。Python会校验search_key == found_key是否为真，如果相等的话，就会返回found_value。
            如果search_key和found_key不匹配的话，这种情况称为散列冲突。这种情况时因为散列表所做的其实是把随机的元素映射到只有几位的数字上，而散列表本身的索引又只依赖于这个数字的一部分，为了解决散列冲突，算法会在散列值中另外再取几位，然后用特殊的方法处理一下， 把新得到的数字再当做索引来寻找表元。
    3.9.3 dict的实现及其导致的结果
        01.键必须是可散列的
            一个可散列的对象必须满足一下要求
            1)支持hash()函数，并且通过__hash__()方法所得到的散列值是不变的
            2)支持通过__eq__()方法来检测相等性
            3)若a==b为真，则hash(a)==hash(b)也为真
            所有用户自定义的对象默认都是可散列的，散列值由id()获取，而且都不相同。
        02.字典在内存上的开销巨大
            由于字典使用了散列表，而散列表又必须是稀疏的，导致在空间上的效率低下。
            需要存放数量巨大的记录，由元组或具名元组构成的列表中会是比较好的选择。
            在用户自定义的类型中,__slots__属性可以改变实例属性的存储方法，由dict变成tuple。
        03.键查询很快
            dict的实现时典型的控件换时间：字典类型有着巨大的内存开销，但是提供了无视数据量大小的快速访问。
        04.键的次序取决于添加顺序
            当往dict里添加新建而有发生散列冲突的时候，新键可能会被安排存放到另一个位置。由dict([(key1, value1), (key2, value2)])和dict([(key2,value2),(key1,value1)])两个字典在比较的时候时相等的。但如果在key1和key2被添加到字典里的过程有冲突发生的话，键出现在字典里的顺序是不一样的。
        05.往字典里添加新键可能会改变已有键的顺序
            无论何时往字典里添加新的键，Python解释器都可能做出为字典扩容的决定。扩容导致的结果就是要新建一个更大的散列表，并把字典里已有的元素添加到新表里。这个过程中可能会发生新的散列冲突，导致新散列表中的键次序变化。
            不能对字典同时进行迭代和修改。如果想要扫描并修改一个字典，最好分为两步。
    3.9.4 set的实现以及导致的结果
        set和frozenset的实现也依赖散列表，但它们的散列表里存放的只有元素的引用。在set加入到Python之前，都是在字典加上无意义的值当做集合使用。
        a.集合里的元素必须是可散列的
        b.集合很消耗内存
        c.可以很高效的判断元素是否存在于某个集合
        d.元素的次序取决于被添加到集合里的次序
        e.往集合里添加元素，可能会改变集合里已有元素的次序

'''


if __name__ == '__main__':
    print(hash(1))
    print(hash(1.0))
    print(hash(1.0001))
    print(hash(1.0002))
    print(hash(1.0003))
    print(hash('hash'))
    print(hash('hash'))
    print(hash('hash') == -9186069675499195770)
