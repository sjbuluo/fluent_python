'''
    增量赋值运算符+=和*=的表现取决于第一个操作对象。
    +=背后的特殊方法是__iadd__方法。如果一个类没有实现这个方法的话，Python会退一步调用__add__方法。
    考虑 a += b。如果a实现了__iadd__方法，则会调用这个方法。同时对可变序列来说，a就会改动，和调用a.extend(b)效果一致。如果没有实现__iadd__方法，a += b就变为a = a + b,先计算得到一个新的对象，再赋值给a
    对不可变序列进行重复拼接操作的话，效率会很低，因为每次都有一个新对象，而解释器需要把原来对象中的元素复制到新的对象中，然后再追加新的元素
    str是一个例外，因为对字符串+=实在太普遍，所以CPython做了优化，为str初始化内存时，会为其预留额外的可扩展空间，因此进行增量操作的时候，并不会涉及赋值原有字符串到新位置这类操作。
    可以使用import dis
        dis.dis('Python代码')
    来查看Python执行的字节码 (也可以使用www.pythontutor.com网站来查看执行过程的数据变化)
    1 不要把可变对象放在元组里面
    2 增量赋值不是一个原子操作
    3 查看Python的字节码并不难，而且对了解代码背后的运行机制很有帮助

'''


if __name__ == '__main__':
    l = [1, 2, 3]
    print(id(l))
    l *= 2
    print(l, id(l))
    t = (1, 2, 3)
    print(id(t))
    t *= 2
    print(t, id(t))

    t = (1, 2, [30, 40])
    #t[2] += [50, 60] # 这行代码会报错 tuple类型不支持对它的元素赋值，所以会抛出TypeError异常 但是t[2]却被改动
    #print(t) 结果为 (1, 2, [30, 40, 50, 60])